using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnnaturalSelection.Character;

namespace UnnaturalSelection.Animation
{
    public enum BreathAnimationMode
    {
        Unrestricted = 0,
        EnableWhenAim = 1,
        DisableWhenAim = 2
    }

    [System.Serializable]
    public class MotionAnimation
    {
        [SerializeField]
        [Tooltip("Determines the overall magnitude of the animation amplitude.")]
        private float scaleFactor = 1;

        [SerializeField]
        [Tooltip("Define the amount of smoothness applied by this controller on the motion animation, useful to create natural-looking animations.")]
        private float smoothness = 1;

        [SerializeField]
        [Tooltip("Provides a set of rules used to simulate the walking animation on the Target Transform.")]
        private MotionData walkingMotionData;

        [SerializeField]
        [Tooltip("Provides a set of rules used to simulate the walking animation on the Target Transform.")]
        private MotionData crouchedMotionData;

        [SerializeField]
        [Tooltip("Provides a set of rules used to simulate the walking animation on the Target Transform (Used when the character has their legs injured).")]
        private MotionData brokenLegsMotionData;

        [SerializeField]
        [Tooltip("Provides a set of rules used to simulate the running animation on the Target Transform.")]
        private MotionData runningMotionData;

        [SerializeField]
        [Tooltip("Defines the transform which will be animated.")]
        private Transform targetTransform;

        [SerializeField]
        private LerpAnimation braceForJumpAnimation = new LerpAnimation(new Vector3(0, -0.2f, 0), new Vector3(5, 0, 0), 0.25f, 0.2f);

        [SerializeField]
        private LerpAnimation jumpAnimation = new LerpAnimation(new Vector3(0, 0.05f, 0), new Vector3(10, 0, 0), 0.15f);

        [SerializeField]
        private LerpAnimation landingAnimation = new LerpAnimation(new Vector3(0, -0.075f, 0), Vector3.zero, 0.15f, 0.15f);

        [SerializeField]
        [Tooltip("Defines the point showing the smallest effect that will be applied when the character gets hit.")]
        private Vector3 minHitRotation = new Vector3(5, -5, 0);

        [SerializeField]
        [Tooltip("Defines the point indicating the maximum effect that will be applied when the character gets hit."
            + " The animation will be generated by computing a random point inside the minimum and maximum bounds, rotating the camera towards the calculated target direction.")]
        private Vector3 maxHitRotation = new Vector3(5, 5, 0);

        [SerializeField]
        [Tooltip("Defines how long the hit animation will last.")]
        private float hitDuration = 0.1f;

        [SerializeField]
        [Tooltip("Enables Breath Animation simulation.")]
        private bool breathAnimation = true;

        [SerializeField]
        [Tooltip("Defines how fast the breathing animation will be.")]
        private float breathingSpeed = 2;

        [SerializeField]
        [Tooltip("Defines the how much the Target Transform will be affected by this animation by increasing the animation amplitude.")]
        private float breathingAmplitude = 1;


        private WeaponKickbackAnimation weaponKickbackAnimation;
        private Vector3 weaponKickbackPos;
        private Vector3 weaponKickbackRot;
        private Vector3 weaponKickbackTargetPos;
        private Vector3 weaponKickbackTargetRot;

        private float nextWeaponRecoilTime;
        private float nextRecoilTime;
        private float nextRecoilDirection;
        private float currentKickBack;
        private float currentRecoilRotation;

        private CameraKickbackAnimation cameraKickbackAnimation;
        private Vector3 cameraKickbackRot;

        [SerializeField]
        private ExplosionShakeProperties explosionShake;

        private const float maxAngle = 90.0f;
        private Vector3 explosionPos;
        private Vector3 explosionRot;

        [SerializeField]
        private LerpAnimation vaultAnimation = new LerpAnimation(Vector3.zero, new Vector3(-10, 0, 10), 0.3f, 0.3f);

        [SerializeField]
        [Tooltip("Enables peek and leaning functions on the character.")]
        private bool lean = true;

        [SerializeField]
        [Range(0, 0.2f)]
        [Tooltip("Defines the horizontal offset while leaning.")]
        private float leanAmount = 0.2f;

        [SerializeField]
        [Tooltip("Defines the angle (in degrees) that the target will be rotated.")]
        private float leanAngle = 10;

        [SerializeField]
        [Tooltip("Defines how fast the animation will be played.")]
        private float leanSpeed = 5;

        private Vector3 targetPos;
        private Quaternion targetRot;

        private Vector3 posAnimated;
        private Vector3 rotAnimated;

        private float anglePosition;
        private float angleRotation;
        private float verticalInfluence;

        private Vector3 currentPos;
        private Vector3 currentRot;

        private Vector3 damageRot;

        private Vector3 leanPos;
        private Vector3 leanRot;

        private Vector3 breathingRot;
        private float breathingProgress;

        public float BlendFactor
        {
            get => smoothness;
            set => smoothness = Mathf.Clamp(value, 0, Mathf.Infinity);
        }

        public float ScaleFactor => scaleFactor;

        public ExplosionShakeProperties ExplosionShake => explosionShake;

        public LerpAnimation BraceForJumpAnimation => braceForJumpAnimation;

        public LerpAnimation JumpAnimation => jumpAnimation;

        public LerpAnimation LandingAnimation => landingAnimation;

        public LerpAnimation VaultAnimation => vaultAnimation;

        public bool Lean => lean;

        public float LeanAmount
        {
            get => leanAmount;
            set => leanAmount = Mathf.Clamp(value, 0, 0.2f);
        }

        public void BreathingAnimation(float speed = 1)
        {
            if (breathAnimation)
            {
                CalculateAngle(ref breathingProgress, breathingSpeed, speed);

                if (speed > 0)
                {
                    float sin = Mathf.Sin(breathingProgress);
                    float cos = Mathf.Cos(breathingProgress);

                    // Calculates the target rotation using the values of sine and cosine multiplied by the animation magnitude.
                    Vector3 breathingRot = new Vector3(sin * cos * breathingAmplitude, sin * breathingAmplitude);

                    this.breathingRot = Vector3.Lerp(this.breathingRot, breathingRot, Time.deltaTime * 5 * breathingSpeed * speed);
                }
                else
                {
                    breathingRot = Vector3.Lerp(breathingRot, Vector3.zero, Time.deltaTime * 5);
                }
            }
            else
            {
                breathingRot = Vector3.Lerp(breathingRot, Vector3.zero, Time.deltaTime * 5);
            }
        }

        public void MovementAnimation(MovementController FPController)
        {
            if (!targetTransform)
                return;

            // Stops the movement animation if the character is not walking or running.
            if (FPController.State == MotionState.Flying || FPController.State == MotionState.Idle || FPController.State == MotionState.Climbing || FPController.IsSliding)
            {
                PerformMovementAnimation(null, FPController.Velocity, 10);
            }
            else
            {
                // Calculates the animation speed
                float speed = Mathf.Max(FPController.State == MotionState.Running ? 6.5f : 2.75f, FPController.CurrentTargetForce);

                // Lowerbody damaged (broken legs)
                if (FPController.LowerBodyDamaged && !FPController.IsAiming)
                {
                    PerformMovementAnimation(brokenLegsMotionData, FPController.IsGrounded ? FPController.Velocity : Vector3.zero, speed);
                }
                else
                {
                    switch (FPController.State)
                    {
                        case MotionState.Running:
                            PerformMovementAnimation(runningMotionData, FPController.IsGrounded ? FPController.Velocity : Vector3.zero, speed);
                            break;
                        case MotionState.Crouched:
                            PerformMovementAnimation(crouchedMotionData, FPController.IsGrounded ? FPController.Velocity : Vector3.zero, speed);
                            break;
                        case MotionState.Walking:
                            PerformMovementAnimation(walkingMotionData, FPController.IsGrounded ? FPController.Velocity : Vector3.zero, speed);
                            break;
                    }
                }
            }

            targetTransform.localPosition = targetPos + (vaultAnimation.Position + weaponKickbackPos + explosionPos + leanPos) * scaleFactor;

            targetTransform.localRotation = targetRot
                                              * Quaternion.Euler(breathingRot)
                                              * Quaternion.Euler(cameraKickbackRot)
                                              * Quaternion.Euler(weaponKickbackRot)
                                              * Quaternion.Euler(explosionRot)
                                              * Quaternion.Euler(damageRot)
                                              * Quaternion.Euler(vaultAnimation.Rotation) * Quaternion.Euler(leanRot);
        }

        private void CalculateAngle(ref float angle, float animationSpeed, float overallSpeed)
        {
            if (angle >= Mathf.PI * 2)
            {
                angle -= Mathf.PI * 2;
            }

            // Sum the time elapsed since the last frame multiplied by the animation speed.
            angle += Time.deltaTime * animationSpeed * overallSpeed;
        }

        private void PerformMovementAnimation(MotionData motionData, Vector3 velocityInfluence, float speed)
        {
            if (motionData)
            {
                CalculateAngle(ref anglePosition, motionData.PositionSpeed, speed);
                CalculateAngle(ref angleRotation, motionData.RotationSpeed, speed);

                float sinPos = Mathf.Sin(anglePosition);
                float cosPos = Mathf.Cos(anglePosition);

                float sinRot = Mathf.Sin(angleRotation);
                float cosRot = Mathf.Cos(angleRotation);

                // Calculates the velocity influence
                verticalInfluence = Mathf.Lerp(verticalInfluence, velocityInfluence.y * motionData.VerticalRotationAmplitude * motionData.VelocityInfluence, Time.deltaTime * speed);

                if (motionData.AnimatePosition)
                {
                    posAnimated = new Vector3(sinPos * motionData.HorizontalPositionAmplitude, Mathf.Abs(cosPos) * motionData.VerticalPositionAmplitude, sinPos * motionData.DistalAmplitude);
                }
                else
                {
                    posAnimated = Vector3.zero;
                }

                // Calculates the current position. (The sum of all the positions of the simulations)
                currentPos = (motionData.PositionOffset + posAnimated) * scaleFactor + jumpAnimation.Position + landingAnimation.Position + braceForJumpAnimation.Position;

                if (motionData.AnimateRotation)
                {
                    rotAnimated = new Vector3(
                                        (-Mathf.Abs(sinRot) * motionData.VerticalRotationAmplitude +
                                         motionData.VerticalRotationAmplitude)
                                        * motionData.VerticalRotationAnimationCurve.Evaluate(Mathf.Abs(cosRot)),
                                        cosRot * motionData.HorizontalRotationAmplitude, cosRot * -motionData.TiltAmplitude)
                                    + new Vector3(verticalInfluence, 0, 0) + motionData.RotationOffset;
                }
                else
                {
                    rotAnimated = Vector3.zero;
                }

                // Calculates the current rotation. (The multiplication of all the rotations of the simulations)
                currentRot = rotAnimated + braceForJumpAnimation.Rotation + jumpAnimation.Rotation + landingAnimation.Rotation;

                // Interpolate from the last position/rotation to the new current position/rotation.
                float blending = 1 / smoothness;
                targetPos = Vector3.Lerp(targetPos, currentPos, Time.deltaTime * blending * motionData.PositionSpeed * speed);
                targetRot = Quaternion.Slerp(targetRot, Quaternion.Euler(currentRot), Time.deltaTime * blending * motionData.RotationSpeed * speed);
            }
            else
            {
                float blending = 1 / smoothness;
                targetPos = Vector3.Lerp(targetPos, jumpAnimation.Position + landingAnimation.Position + braceForJumpAnimation.Position, Time.deltaTime * blending * 5);
                targetRot = Quaternion.Slerp(targetRot, Quaternion.Euler(braceForJumpAnimation.Rotation) *
                                                            Quaternion.Euler(jumpAnimation.Rotation)
                                                            * Quaternion.Euler(landingAnimation.Rotation), Time.deltaTime * blending * 5);

                verticalInfluence = 0;

                // Random angle of initialization for the next animation.
                anglePosition = Random.Range(0, 10) % 2 == 0 ? 0 : Mathf.PI;
                angleRotation = Random.Range(0, 10) % 2 == 0 ? 0 : Mathf.PI;
            }
        }

        public void LeanAnimation(int direction)
        {
            // direction = 1   -> Right
            // direction = -1  -> Left
            if (lean)
            {
                switch (direction)
                {
                    case 1:
                        leanPos = Vector3.Lerp(leanPos, new Vector3(leanAmount, 0, 0), Time.deltaTime * leanSpeed);
                        leanRot = Vector3.Lerp(leanRot, new Vector3(0, 0, -leanAngle), Time.deltaTime * leanSpeed);
                        break;
                    case -1:
                        leanPos = Vector3.Lerp(leanPos, new Vector3(-leanAmount, 0, 0), Time.deltaTime * leanSpeed);
                        leanRot = Vector3.Lerp(leanRot, new Vector3(0, 0, leanAngle), Time.deltaTime * leanSpeed);
                        break;
                    default:
                        leanPos = Vector3.Lerp(leanPos, Vector3.zero, Time.deltaTime * leanSpeed);
                        leanRot = Vector3.Lerp(leanRot, Vector3.zero, Time.deltaTime * leanSpeed);
                        break;
                }
            }
            else
            {
                leanPos = Vector3.zero;
                leanRot = Vector3.zero;
            }
        }

        public IEnumerator HitAnimation()
        {
            Vector3 initialRot = RandomInsideBounds(minHitRotation, maxHitRotation);

            // Make the GameObject move to target slightly
            for (float t = 0f; t <= hitDuration; t += Time.deltaTime)
            {
                damageRot = Vector3.Lerp(initialRot, initialRot, t / hitDuration);
                yield return new WaitForFixedUpdate();
            }

            // Make it move back to neutral
            for (float t = 0f; t <= hitDuration; t += Time.deltaTime)
            {
                damageRot = Vector3.Lerp(initialRot, Vector3.zero, t / hitDuration);
                yield return new WaitForFixedUpdate();
            }

            damageRot = Vector3.zero;
        }

        private Vector3 RandomInsideBounds(Vector3 min, Vector3 max)
        {
            return new Vector3(Random.Range(min.x, max.x), Random.Range(min.y, max.y), Random.Range(min.z, max.z));
        }

        public void WeaponRecoilAnimation(WeaponKickbackAnimation weaponKickbackAnimation)
        {
            if (nextWeaponRecoilTime > Time.time || !weaponKickbackAnimation.Enabled)
                return;

            this.weaponKickbackAnimation = weaponKickbackAnimation;
            float xPos = this.weaponKickbackAnimation.SidewaysForce * Random.Range(this.weaponKickbackAnimation.SidewaysRandomness.x, this.weaponKickbackAnimation.SidewaysRandomness.y);
            float yPos = this.weaponKickbackAnimation.UpwardForce * Random.Range(this.weaponKickbackAnimation.UpwardRandomness.x, this.weaponKickbackAnimation.UpwardRandomness.y);
            float zPos = -this.weaponKickbackAnimation.KickbackForce * Random.Range(this.weaponKickbackAnimation.KickbackRandomness.x, this.weaponKickbackAnimation.KickbackRandomness.y);
            weaponKickbackTargetPos = new Vector3(xPos, yPos, zPos);

            float xRot = -this.weaponKickbackAnimation.VerticalRotation * Random.Range(this.weaponKickbackAnimation.VerticalRotationRandomness.x, this.weaponKickbackAnimation.VerticalRotationRandomness.y);
            float yRot = this.weaponKickbackAnimation.HorizontalRotation * Random.Range(this.weaponKickbackAnimation.HorizontalRotationRandomness.x, this.weaponKickbackAnimation.HorizontalRotationRandomness.y);
            weaponKickbackTargetRot = new Vector3(xRot, yRot, 0);
            nextWeaponRecoilTime = Time.time + this.weaponKickbackAnimation.KickbackDuration;
        }

        public void CameraRecoilAnimation(CameraKickbackAnimation cameraKickbackAnimation)
        {
            if (nextRecoilTime > Time.time || !cameraKickbackAnimation.Enabled)
                return;

            this.cameraKickbackAnimation = cameraKickbackAnimation;
            nextRecoilDirection = Random.Range(this.cameraKickbackAnimation.KickbackRandomness.x, this.cameraKickbackAnimation.KickbackRandomness.y);
            currentKickBack = Mathf.Clamp(currentKickBack + this.cameraKickbackAnimation.Kickback * nextRecoilDirection, -this.cameraKickbackAnimation.MaxKickback, this.cameraKickbackAnimation.MaxKickback);
            currentRecoilRotation = Mathf.Clamp(Random.Range(this.cameraKickbackAnimation.HorizontalKickbackRandomness.x, this.cameraKickbackAnimation.HorizontalKickbackRandomness.y) * this.cameraKickbackAnimation.HorizontalKickback + currentRecoilRotation, -this.cameraKickbackAnimation.HorizontalKickback, this.cameraKickbackAnimation.HorizontalKickback);
            nextRecoilTime = Time.time + cameraKickbackAnimation.KickbackDuration;
        }

        public void StabiliseCameraRecoil()
        {
            if (nextRecoilTime > Time.time)
            {
                Vector3 target = new Vector3(-currentKickBack, currentRecoilRotation, currentRecoilRotation * cameraKickbackAnimation.KickbackRotation);
                cameraKickbackRot = Vector3.MoveTowards(cameraKickbackRot, target, Time.deltaTime * cameraKickbackAnimation.KickbackSpeed);
            }
            else
                cameraKickbackRot = Vector3.Slerp(cameraKickbackRot, Vector3.zero, Time.deltaTime * 10);
        }

        public void StabiliseWeaponRecoil()
        {
            if (weaponKickbackAnimation == null || !weaponKickbackAnimation.Enabled)
                return;

            weaponKickbackPos = Vector3.Lerp(weaponKickbackPos, weaponKickbackTargetPos, Time.deltaTime * weaponKickbackAnimation.KickbackSpeed);
            weaponKickbackTargetPos = Vector3.Lerp(weaponKickbackTargetPos, Vector3.zero, Time.deltaTime * weaponKickbackAnimation.KickbackSpeed);
            weaponKickbackRot = Vector3.Lerp(weaponKickbackRot, weaponKickbackTargetRot, Time.deltaTime * weaponKickbackAnimation.KickbackSpeed);
            weaponKickbackTargetRot = Vector3.Lerp(weaponKickbackTargetRot, Vector3.zero, Time.deltaTime * weaponKickbackAnimation.KickbackSpeed);
        }
        public IEnumerator Shake(ExplosionShakeProperties prop)
        {
            // Original code written by Sebastian Lague.
            // https://github.com/SebLague/Camera-Shake

            float completionPercent = 0;
            float movePercent = 0;

            float radians = prop.Angle * Mathf.Deg2Rad - Mathf.PI;
            Vector3 previousWaypoint = Vector3.zero;
            Vector3 currentWaypoint = Vector3.zero;
            float moveDistance = 0;
            float speed = 0;

            Vector3 targetRotation = Vector3.zero;
            Vector3 previousRotation = Vector3.zero;

            do
            {
                if (movePercent >= 1 || Mathf.Abs(completionPercent) < Mathf.Epsilon)
                {
                    float dampingFactor = DampingCurve(completionPercent, prop.DampingPercent);
                    float noiseAngle = (Random.value - 0.5f) * Mathf.PI;
                    radians += Mathf.PI + noiseAngle * prop.NoisePercent;
                    currentWaypoint = new Vector3(Mathf.Cos(radians), Mathf.Sin(radians)) * (prop.Strength * dampingFactor);
                    previousWaypoint = explosionPos;
                    moveDistance = Vector3.Distance(currentWaypoint, previousWaypoint);

                    targetRotation = new Vector3(currentWaypoint.y, currentWaypoint.x).normalized * (prop.RotationPercent * dampingFactor * maxAngle);
                    previousRotation = explosionRot;

                    speed = Mathf.Lerp(prop.MinSpeed, prop.MaxSpeed, dampingFactor);

                    movePercent = 0;
                }

                completionPercent += Time.deltaTime / prop.Duration;
                movePercent += Time.deltaTime / moveDistance * speed;
                explosionPos = Vector3.Lerp(previousWaypoint, currentWaypoint, movePercent);
                explosionRot = Vector3.Lerp(previousRotation, targetRotation, movePercent);

                yield return null;

            } while (moveDistance > 0);
        }

        private static float DampingCurve(float x, float dampingPercent)
        {
            float a = Mathf.Lerp(2, .25f, dampingPercent);
            float b = 1 - Mathf.Pow(Mathf.Clamp01(x), a);
            return Mathf.Pow(b, 3);
        }
    }
}
